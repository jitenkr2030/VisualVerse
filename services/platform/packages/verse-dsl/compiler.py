"""
VerseScript DSL Compiler

This module provides the compiler that converts VerseScript AST (Abstract Syntax Tree)
into VisualVerse configuration objects ready for rendering by the visual services.

Author: MiniMax Agent
Version: 1.0.0
"""

from typing import Dict, List, Optional, Any, TypeVar, Callable
from dataclasses import dataclass, field
from datetime import datetime
import json
import hashlib
import logging

from .parser import (
    Program,
    SceneDirective,
    EntityDefinition,
    VariableAssignment,
    FunctionDefinition,
    FunctionCall,
    IfStatement,
    ForLoop,
    WhileLoop,
    AnimationBlock,
    Literal,
    Identifier,
    PropertyAccess,
    BinaryOperation,
    UnaryOperation,
    ListLiteral,
    DictLiteral,
    ImportStatement,
    ReturnStatement,
    ASTNodeType,
    BinaryOperator,
    UnaryOperator
)


logger = logging.getLogger(__name__)


class CompilationError(Exception):
    """Exception raised during compilation errors."""
    
    def __init__(self, message: str, node=None, suggestions: List[str] = None):
        self.message = message
        self.node = node
        self.suggestions = suggestions or []
        super().__init__(self._format_message())
    
    def _format_message(self) -> str:
        result = self.message
        if self.node and hasattr(self.node, 'position') and self.node.position:
            result += f" (line {self.node.position.line})"
        if self.suggestions:
            result += "\nSuggestions:\n  - " + "\n  - ".join(self.suggestions)
        return result


@dataclass
class CompilationResult:
    """Result of compiling VerseScript to VisualVerse config."""
    success: bool
    config: Dict[str, Any]
    warnings: List[str] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "success": self.success,
            "config": self.config,
            "warnings": self.warnings,
            "errors": self.errors,
            "metadata": self.metadata
        }
    
    def to_json(self) -> str:
        return json.dumps(self.to_dict(), indent=2)


@dataclass
class EntityConfig:
    """Compiled entity configuration."""
    id: str
    entity_type: str
    properties: Dict[str, Any] = field(default_factory=dict)
    animations: List[Dict[str, Any]] = field(default_factory=list)
    position: Optional[Dict[str, float]] = None
    visible: bool = True
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "entityType": self.entity_type,
            "properties": self.properties,
            "animations": self.animations,
            "position": self.position,
            "visible": self.visible
        }


@dataclass
class SceneConfig:
    """Compiled scene configuration."""
    width: int = 800
    height: int = 600
    background_color: str = "#FFFFFF"
    entities: List[EntityConfig] = field(default_factory=list)
    animations: List[Dict[str, Any]] = field(default_factory=list)
    interactions: Dict[str, Any] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "width": self.width,
            "height": self.height,
            "backgroundColor": self.background_color,
            "entities": [e.to_dict() for e in self.entities],
            "animations": self.animations,
            "interactions": self.interactions,
            "metadata": self.metadata
        }


class DSLCompiler:
    """
    Compiler for converting VerseScript AST to VisualVerse configuration.
    
    This compiler processes the abstract syntax tree generated by the parser
    and produces configuration objects compatible with the VisualVerse rendering
    services.
    """
    
    def __init__(self, domain: str = "general"):
        self.domain = domain
        self._entities: Dict[str, EntityConfig] = {}
        self._variables: Dict[str, Any] = {}
        self._functions: Dict[str, FunctionDefinition] = {}
        self._scene_config: SceneConfig = SceneConfig()
        self._warnings: List[str] = []
        self._errors: List[str] = []
        self._domain_compilers: Dict[str, Callable] = {
            "math": self._compile_math_domain,
            "physics": self._compile_physics_domain,
            "chemistry": self._compile_chemistry_domain,
            "algorithms": self._compile_algorithm_domain,
            "finance": self._compile_finance_domain,
        }
    
    def compile(self, program: Program) -> CompilationResult:
        """
        Compile a VerseScript program to VisualVerse configuration.
        
        Args:
            program: The parsed AST program
            
        Returns:
            CompilationResult containing the compiled configuration
        """
        self._reset_state()
        self.domain = program.domain
        
        try:
            # Process scene directive
            for directive in program.directives:
                self._compile_directive(directive)
            
            # Process statements
            for statement in program.statements:
                self._compile_statement(statement)
            
            # Domain-specific compilation
            if self.domain in self._domain_compilers:
                self._domain_compilers[self.domain]()
            
            # Build final configuration
            config = self._build_final_config()
            
            return CompilationResult(
                success=len(self._errors) == 0,
                config=config,
                warnings=self._warnings,
                errors=self._errors,
                metadata={
                    "domain": self.domain,
                    "entity_count": len(self._entities),
                    "compiled_at": datetime.utcnow().isoformat()
                }
            )
        
        except Exception as e:
            logger.error(f"Compilation error: {e}")
            return CompilationResult(
                success=False,
                config={},
                errors=[str(e)],
                warnings=self._warnings
            )
    
    def _reset_state(self):
        """Reset compiler state."""
        self._entities = {}
        self._variables = {}
        self._functions = {}
        self._scene_config = SceneConfig()
        self._warnings = []
        self._errors = []
    
    def _compile_directive(self, directive: SceneDirective):
        """Compile scene directive."""
        attributes = directive.attributes
        
        if "width" in attributes:
            self._scene_config.width = int(attributes["width"])
        if "height" in attributes:
            self._scene_config.height = int(attributes["height"])
        if "background" in attributes:
            self._scene_config.background_color = str(attributes["background"])
        if "type" in attributes:
            self._scene_config.metadata["scene_type"] = attributes["type"]
    
    def _compile_statement(self, statement) -> Any:
        """Compile a statement."""
        if isinstance(statement, EntityDefinition):
            return self._compile_entity_definition(statement)
        elif isinstance(statement, VariableAssignment):
            return self._compile_variable_assignment(statement)
        elif isinstance(statement, FunctionDefinition):
            return self._compile_function_definition(statement)
        elif isinstance(statement, FunctionCall):
            return self._compile_function_call(statement)
        elif isinstance(statement, IfStatement):
            return self._compile_if_statement(statement)
        elif isinstance(statement, ForLoop):
            return self._compile_for_loop(statement)
        elif isinstance(statement, WhileLoop):
            return self._compile_while_loop(statement)
        elif isinstance(statement, AnimationBlock):
            return self._compile_animation_block(statement)
        else:
            self._warnings.append(f"Unsupported statement type: {type(statement)}")
            return None
    
    def _compile_entity_definition(self, node: EntityDefinition) -> EntityConfig:
        """Compile entity definition."""
        entity = EntityConfig(
            id=node.name,
            entity_type=node.entity_type,
            properties=node.properties
        )
        
        # Set default position if specified in properties
        if "position" in node.properties:
            pos = node.properties["position"]
            if isinstance(pos, tuple) and len(pos) >= 2:
                entity.position = {"x": float(pos[0]), "y": float(pos[1]), "z": 0}
        
        self._entities[node.name] = entity
        self._scene_config.entities.append(entity)
        
        logger.debug(f"Compiled entity: {node.name} (type: {node.entity_type})")
        return entity
    
    def _compile_variable_assignment(self, node: VariableAssignment) -> Any:
        """Compile variable assignment."""
        value = self._evaluate_expression(node.value)
        self._variables[node.name] = value
        return value
    
    def _compile_function_definition(self, node: FunctionDefinition):
        """Compile function definition."""
        self._functions[node.name] = node
    
    def _compile_function_call(self, node: FunctionCall) -> Any:
        """Compile function call."""
        func_name = node.function_name
        
        # Built-in functions
        if func_name == "animate":
            return self._compile_animate_function(node)
        elif func_name == "set_property":
            return self._compile_set_property_function(node)
        elif func_name == "wait":
            return self._compile_wait_function(node)
        elif func_name == "export":
            return self._compile_export_function(node)
        elif func_name == "run":
            return self._compile_run_function(node)
        elif func_name in self._functions:
            return self._compile_user_defined_function(node)
        else:
            self._warnings.append(f"Unknown function: {func_name}")
            return None
    
    def _compile_animate_function(self, node: FunctionCall) -> Dict[str, Any]:
        """Compile animate function call."""
        if len(node.arguments) < 2:
            self._errors.append("animate() requires at least 2 arguments")
            return None
        
        target = self._evaluate_expression(node.arguments[0])
        animation_type = self._evaluate_expression(node.arguments[1])
        
        params = {}
        for i in range(2, len(node.arguments)):
            arg = node.arguments[i]
            if isinstance(arg, FunctionCall):
                if arg.function_name == "duration":
                    params["duration"] = self._evaluate_expression(arg.arguments[0])
                elif arg.function_name == "easing":
                    params["easing"] = self._evaluate_expression(arg.arguments[0])
        
        animation = {
            "type": animation_type,
            "target": target,
            "parameters": params
        }
        
        self._scene_config.animations.append(animation)
        return animation
    
    def _compile_set_property_function(self, node: FunctionCall) -> Any:
        """Compile set_property function call."""
        if len(node.arguments) < 3:
            self._errors.append("set_property() requires 3 arguments")
            return None
        
        object_name = self._evaluate_expression(node.arguments[0])
        property_name = self._evaluate_expression(node.arguments[1])
        value = self._evaluate_expression(node.arguments[2])
        
        if object_name in self._entities:
            self._entities[object_name].properties[property_name] = value
        
        return value
    
    def _compile_wait_function(self, node: FunctionCall) -> Dict[str, Any]:
        """Compile wait function call."""
        if len(node.arguments) >= 1:
            duration = self._evaluate_expression(node.arguments[0])
        else:
            duration = 1000
        
        return {"type": "wait", "duration_ms": duration}
    
    def _compile_export_function(self, node: FunctionCall) -> List[str]:
        """Compile export function call."""
        exported = []
        for arg in node.arguments:
            if isinstance(arg, Identifier):
                exported.append(arg.name)
                if arg.name in self._entities:
                    self._entities[arg.name].visible = True
        return exported
    
    def _compile_run_function(self, node: FunctionCall) -> Any:
        """Compile run function call."""
        if len(node.arguments) >= 1:
            func_name = self._evaluate_expression(node.arguments[0])
            if func_name in self._functions:
                return self._compile_user_defined_function(node.arguments[0])
        return None
    
    def _compile_user_defined_function(self, node: FunctionCall) -> Any:
        """Compile user-defined function call."""
        func_name = node.function_name
        
        if func_name not in self._functions:
            return None
        
        func_def = self._functions[func_name]
        
        # Evaluate arguments
        args = [self._evaluate_expression(arg) for arg in node.arguments]
        
        # Create function context
        old_vars = self._variables.copy()
        for i, param in enumerate(func_def.parameters):
            if i < len(args):
                self._variables[param] = args[i]
        
        # Execute function body
        result = None
        for statement in func_def.body:
            result = self._compile_statement(statement)
            if isinstance(statement, ReturnStatement):
                break
        
        # Restore context
        self._variables = old_vars
        
        return result
    
    def _compile_if_statement(self, node: IfStatement) -> Any:
        """Compile if statement."""
        condition = self._evaluate_expression(node.condition)
        
        if condition:
            for statement in node.then_branch:
                self._compile_statement(statement)
        else:
            for statement in node.else_branch:
                self._compile_statement(statement)
        
        return None
    
    def _compile_for_loop(self, node: ForLoop) -> Any:
        """Compile for loop."""
        iterable = self._evaluate_expression(node.iterable)
        
        if not isinstance(iterable, (list, tuple)):
            self._warnings.append("For loop requires iterable")
            return None
        
        old_vars = self._variables.copy()
        
        for item in iterable:
            self._variables[node.variable] = item
            for statement in node.body:
                self._compile_statement(statement)
        
        self._variables = old_vars
        return None
    
    def _compile_while_loop(self, node: WhileLoop) -> Any:
        """Compile while loop."""
        max_iterations = 1000  # Prevent infinite loops
        iteration = 0
        
        old_vars = self._variables.copy()
        
        while self._evaluate_expression(node.condition) and iteration < max_iterations:
            for statement in node.body:
                self._compile_statement(statement)
            iteration += 1
        
        if iteration >= max_iterations:
            self._warnings.append("While loop exceeded maximum iterations")
        
        self._variables = old_vars
        return None
    
    def _compile_animation_block(self, node: AnimationBlock) -> Dict[str, Any]:
        """Compile animation block."""
        animation = {
            "type": node.animation_type,
            "target": node.target,
            "parameters": node.parameters,
            "duration_ms": node.duration_ms,
            "easing": node.easing
        }
        
        self._scene_config.animations.append(animation)
        return animation
    
    def _evaluate_expression(self, node) -> Any:
        """Evaluate an expression node."""
        if node is None:
            return None
        
        if isinstance(node, Literal):
            return node.value
        
        if isinstance(node, Identifier):
            return self._variables.get(node.name, node.name)
        
        if isinstance(node, PropertyAccess):
            obj = self._variables.get(node.object_name, {})
            if isinstance(obj, dict):
                return obj.get(node.property_name)
            if hasattr(obj, node.property_name):
                return getattr(obj, node.property_name)
            return None
        
        if isinstance(node, BinaryOperation):
            left = self._evaluate_expression(node.left)
            right = self._evaluate_expression(node.right)
            return self._apply_binary_operator(left, node.operator, right)
        
        if isinstance(node, UnaryOperation):
            operand = self._evaluate_expression(node.operand)
            return self._apply_unary_operator(node.operator, operand)
        
        if isinstance(node, ListLiteral):
            return [self._evaluate_expression(e) for e in node.elements]
        
        if isinstance(node, DictLiteral):
            return {k: self._evaluate_expression(v) for k, v in node.pairs.items()}
        
        if isinstance(node, FunctionCall):
            return self._compile_function_call(node)
        
        return str(node)
    
    def _apply_binary_operator(self, left: Any, operator: BinaryOperator, right: Any) -> Any:
        """Apply a binary operator."""
        op = operator.value if hasattr(operator, 'value') else operator
        
        if op == "+":
            return left + right
        elif op == "-":
            return left - right
        elif op == "*":
            return left * right
        elif op == "/":
            return left / right if right != 0 else 0
        elif op == "%":
            return left % right
        elif op == "**":
            return left ** right
        elif op == "==":
            return left == right
        elif op == "!=":
            return left != right
        elif op == "<":
            return left < right
        elif op == ">":
            return left > right
        elif op == "<=":
            return left <= right
        elif op == ">=":
            return left >= right
        elif op in ("and", "&"):
            return left and right
        elif op in ("or", "|"):
            return left or right
        
        return left
    
    def _apply_unary_operator(self, operator: UnaryOperator, operand: Any) -> Any:
        """Apply a unary operator."""
        op = operator.value if hasattr(operator, 'value') else operator
        
        if op == "-":
            return -operand
        elif op == "not":
            return not operand
        
        return operand
    
    # Domain-specific compilation methods
    def _compile_math_domain(self):
        """Compile math domain-specific features."""
        self._scene_config.metadata["domain"] = "math"
        
        # Process any mathematical configurations
        for entity in self._entities.values():
            if entity.entity_type in ("Graph", "Plot", "Equation"):
                entity.properties["domain"] = "math"
    
    def _compile_physics_domain(self):
        """Compile physics domain-specific features."""
        self._scene_config.metadata["domain"] = "physics"
        
        # Set up physics simulation defaults
        if "gravity" not in self._scene_config.metadata:
            self._scene_config.metadata["gravity"] = 9.81
        
        for entity in self._entities.values():
            if entity.entity_type in ("Body", "Particle", "RigidBody"):
                entity.properties["physics_enabled"] = True
    
    def _compile_chemistry_domain(self):
        """Compile chemistry domain-specific features."""
        self._scene_config.metadata["domain"] = "chemistry"
        
        for entity in self._entities.values():
            if entity.entity_type in ("Molecule", "Atom", "Bond"):
                entity.properties["domain"] = "chemistry"
    
    def _compile_algorithm_domain(self):
        """Compile algorithm domain-specific features."""
        self._scene_config.metadata["domain"] = "algorithms"
        
        for entity in self._entities.values():
            if entity.entity_type in ("Array", "List", "Tree", "Graph"):
                entity.properties["domain"] = "algorithms"
                entity.properties["highlight_color"] = "#FFFF00"
    
    def _compile_finance_domain(self):
        """Compile finance domain-specific features."""
        self._scene_config.metadata["domain"] = "finance"
        
        for entity in self._entities.values():
            if entity.entity_type in ("Chart", "Candlestick", "Bar"):
                entity.properties["domain"] = "finance"
    
    def _build_final_config(self) -> Dict[str, Any]:
        """Build the final VisualVerse configuration."""
        return {
            "version": "1.0.0",
            "domain": self.domain,
            "scene": self._scene_config.to_dict(),
            "entities": {name: entity.to_dict() for name, entity in self._entities.items()},
            "animations": self._scene_config.animations,
            "variables": self._variables,
            "generated_at": datetime.utcnow().isoformat()
        }


class MathDSLCompiler(DSLCompiler):
    """Specialized compiler for mathematical content."""
    
    def __init__(self):
        super().__init__(domain="math")
        self._equations: List[Dict[str, Any]] = []
        self._graphs: List[Dict[str, Any]] = []
    
    def compile(self, program: Program) -> CompilationResult:
        """Compile with math-specific processing."""
        result = super().compile(program)
        
        # Add math-specific metadata
        if result.success:
            result.config["math_specific"] = {
                "equations": self._equations,
                "graphs": self._graphs,
                "supports_3d": True,
                "supports_parametric": True,
                "supports_implicit": True
            }
        
        return result


class PhysicsDSLCompiler(DSLCompiler):
    """Specialized compiler for physics simulations."""
    
    def __init__(self):
        super().__init__(domain="physics")
        self._simulation_config: Dict[str, Any] = {}
    
    def compile(self, program: Program) -> CompilationResult:
        """Compile with physics-specific processing."""
        result = super().compile(program)
        
        if result.success:
            result.config["physics_specific"] = {
                "simulation": self._simulation_config,
                "collision_detection": True,
                "gravity": -9.81,
                "supported_constraints": ["fixed", "hinge", "slider"]
            }
        
        return result


class AlgorithmDSLCompiler(DSLCompiler):
    """Specialized compiler for algorithm visualizations."""
    
    def __init__(self):
        super().__init__(domain="algorithms")
        self._steps: List[Dict[str, Any]] = []
        self._data_structures: Dict[str, Any] = {}
    
    def compile(self, program: Program) -> CompilationResult:
        """Compile with algorithm-specific processing."""
        result = super().compile(program)
        
        if result.success:
            result.config["algorithm_specific"] = {
                "steps": self._steps,
                "data_structures": self._data_structures,
                "supports_step_by_step": True,
                "supports_speed_control": True
            }
        
        return result


def compile_verse_script(source: str) -> CompilationResult:
    """
    Convenience function to compile VerseScript source code.
    
    Args:
        source: The VerseScript source code
        
    Returns:
        CompilationResult containing the compiled configuration
    """
    from .parser import parse_verse_script
    
    try:
        program = parse_verse_script(source)
        compiler = DSLCompiler(domain=program.domain)
        return compiler.compile(program)
    except Exception as e:
        return CompilationResult(
            success=False,
            config={},
            errors=[str(e)]
        )


__all__ = [
    "CompilationError",
    "CompilationResult",
    "EntityConfig",
    "SceneConfig",
    "DSLCompiler",
    "MathDSLCompiler",
    "PhysicsDSLCompiler",
    "AlgorithmDSLCompiler",
    "compile_verse_script"
]
